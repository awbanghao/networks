---
title: "Bridging resilience factors and successful ageing dimensions: A network analysis"
author: "Timothy"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: cerulean
    code_folding: show
  editor_options:
    chunk_output_type: inline
---

# Chunk options
```{r, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(
  echo      = TRUE,
  message   = FALSE,
  warning   = FALSE,
  error     = FALSE)
```

# Environment
```{r, message = FALSE, warning = FALSE}
rm(list = ls(all.names = TRUE))
seed <- 1337
options(scipen = 999)
cat("\014")
```

# Packages
```{r, message = FALSE, warning = FALSE}
packages <- c(
  "conflicted"

# hardware
, "parallel"             # detectCores()

# knitting
, "rmarkdown"

# data management
, "tidyverse"
, "dplyr"
, "tidyr"
, "knitr"
, "rmarkdown"            # paged_table()
, "readxl"
, "forcats"              # fct_infreq()
, "Hmisc"                # rcorr()

# statistical tests
, "matrixcalc"           # is.positive.definite()
, "rstatix"
, "psych"
, "dlookr"               # find_skewness()

# visualisation
, "ggplot2" 
, "ggcorrplot"           # ggcorrplot()
, "devtools"

# computational tools
, "missRanger"           # missRanger()

# network tools
, "networktools"         # goldbricker()
, "bootnet" 
, "igraph"
, "mgm"
, "qgraph"
, "NetworkToolbox"
)

invisible(lapply(packages,
  \(p) {if (!requireNamespace(p, quietly = TRUE)) install.packages(p)
        library(p, character.only = TRUE)}))
```

# Functions
Functions deconflicted with the **conflicted** package (Wickham, 2024).

**Author**: Wickham, H. (2024). *conflicted: An alternative conflict resolution strategy (Version 1.2.0)* [R package]. CRAN.
```{r, message = FALSE, warning = FALSE}
conflict_scout()

functions <- c(
  filter    = "dplyr",
  recode    = "dplyr",
  select    = "dplyr",
  describe  = "psych",
  summarize = "dplyr",
  mutate    = "dplyr")

invisible(lapply(names(functions), function(f) conflict_prefer(f, functions[f])))
```

# Data
```{r, message = FALSE, warning = FALSE}
# Original dataset accessible at https://osf.io/7xcmy/files/f68nh.
# Codebook accessible at https://www.icpsr.umich.edu/web/NAHDAP/series/706/variables.
```

# Import
Dataset imported with the **readxl** package (Wickham & Bryan, 2025).

**Author**: Wickham, H., & Bryan, J. (2025). *readxl: Read Excel files (Version 1.4.5)* [R package]. CRAN.
```{r, message = FALSE, warning = FALSE, eval = FALSE}
raw <- read_excel("Networks_Dataset_140226.xlsx"
, sheet = "34921-0001-Data"
, skip = 10
, col_names = TRUE)

save(raw, file = "raw.RData")
```

```{r}
load("raw.RData")
```

# Variables
```{r}
df <- raw %>% select(
# number of major diseases (later reversed)
  chr1  = STROKE...22
, chr2  = ALZHEIMER...25
, chr3  = DEMENTIA...26
, chr4  = PARKINSON...27
, chr5  = CANCER
, chr6  = `HYPERTENSION (CONDITNS_6)`
, chr7  = `DIABETES(CONDITNS_7)`
, chr8  = `EMPHYSEMA/ASTHMA (EMPHASTH)`
, chr9  = ARTHRITIS...92
, chr10 = `HEART PROBLEMS (HRTPROB2)`
        
# difficulties with adls (later reversed)
, adl1  = PREPMEAL
, adl2  = TAKEMEDS
, adl3  = MANAGEMONEY
, adl4  = SHOPFOOD
, adl5  = LIGHTWORK
, adl6  = USETELEP
, adl7  = WALKROOM
, adl8  = BATHING
, adl9  = EATING
, adl10 = INOUTBED
, adl11 = TOILET
       
# self-rated physical health
, phy   = PHYSHLTH...82
       
# cognitive performance
, cog   = MOCA...17

# frequency of socialising
, soc   = SOCIAL
              
# community participation
, com1  = VOLUNTEER
, com2  = ATTEND
, com3  = ATNDSERV2
       
# depression
, dep1  = NOTEAT
, dep2  = FLTDEP
, dep3  = FLTEFF
, dep4  = NOSLEEP
, dep5r = WASHAPY # to reverse
, dep6  = WASLONLY
, dep7  = UNFRIEND
, dep8r = ENJLIFE # to reverse
, dep9  = FLTSAD
, dep10 = DISLIKD
       
# anxiety
, anx1  = FLTTENS
, anx2  = FRIGHT
, anx3  = WORRY
, anx4r = RELAXED # to reverse
, anx5  = BUTRFLY
, anx6  = RESTLES
, anx7  = PANIC
        
# happiness
, hap   = HAPPY
        
# loneliness
, lon1  = COMPANION2
, lon2  = LEFTOUT2
, lon3  = ISOLATED2
        
# self-rated mental health 
, men   = MNTLHLTH...64
        
# physical activity
, act   = PHYSACT2...12
        
# alcohol consumption per week
, alc   = DRNKWKLY
        
# cigarettes per day
, smk   = AVECIG
        
# weight and height
, wei   = WEIGHT...61
, hei   = HEIGHT
        
# age
, age   = AGE
        
# educational attainment
, edu   = EDUC...151
        
# number of friends
, fri   = FRAMT
        
# income
, inc   = INCOME_1...8)

df %>% describe() %>% paged_table()
```

# Values
```{r}
df$chr5[df$chr5 == 0.02] <- 1
df$chr5[df$chr5 == 0.01] <- 1

recode_map <- list(
  
# from codebook
  alc  = c(-3, 0)
, smk  = c(-3, 0)
, men  = c(2.5, 0)
, phy  = c(2.5, 0)
, inc  = c(2.7, 0)
  
# researcher-derived
, chr1 = c(0.01, 1)
, chr2 = c(0.01, 1)
, chr3 = c(0.01, 1)
, chr4 = c(0.01, 1)
, chr5 = c(0.02, 1)
, chr5 = c(0.01, 1)
, chr6 = c(0.01, 1)
, chr7 = c(0.01, 1)
, chr8 = c(0.01, 1)
, chr9 = c(0.01, 1)
, chr10 = c(0.01, 1)
, chr5 = c(2, 1)
)

for (v in names(recode_map)) {
  from <- recode_map[[v]][1]
  to   <- recode_map[[v]][2]
  df[[v]][df[[v]] == from] <- to
}

na_rules <- list(
  
# replace invalid values
  chr1 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(0, 1)))
, chr2 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(0, 1)))
, chr3 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(0, 1)))
, chr4 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(0, 1)))
, chr5 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(0, 1)))
, chr6 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(0, 1)))
, chr7 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(0, 1)))
, chr8 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(0, 1)))
, chr9 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(0, 1)))
, chr10 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(0, 1)))
               
, adl1 = list(discrete = c(-8, -3, -2, -1, 4), range = list(c(0, 3)))
, adl2 = list(discrete = c(-8, -3, -2, -1, 4), range = list(c(0, 3)))
, adl3 = list(discrete = c(-8, -3, -2, -1, 4), range = list(c(0, 3)))
, adl4 = list(discrete = c(-8, -3, -2, -1, 4), range = list(c(0, 3)))
, adl5 = list(discrete = c(-8, -3, -2, -1, 4), range = list(c(0, 3)))
, adl6 = list(discrete = c(-8, -3, -2, -1, 4), range = list(c(0, 3)))
, adl7 = list(discrete = c(-8, -3, -2, -1, 4), range = list(c(0, 3)))
, adl8 = list(discrete = c(-8, -3, -2, -1, 4), range = list(c(0, 3)))
, adl9 = list(discrete = c(-8, -3, -2, -1, 4), range = list(c(0, 3)))
, adl10 = list(discrete = c(-8, -3, -2, -1, 4), range = list(c(0, 3)))
, adl11 = list(discrete = c(-8, -3, -2, -1, 4), range = list(c(0, 3)))
  
, phy = list(discrete = c(-4, -3, -2, -1), range = list(c(1, 5)))
, cog = list(discrete = c(-4, -3, -2, -1), range = list(c(0, 30)))
  
, com1 = list(discrete = c(-5, -4, -3, -2, -1), range = list(c(0, 6)))
, com2 = list(discrete = c(-5, -4, -3, -2, -1), range = list(c(0, 6)))
, com3 = list(discrete = c(-8, -5, -4, -3, -2, -1), range = list(c(0, 5)))
  
, soc = list(discrete = c(-5, -4, -3, -2, -1), range = list(c(0, 6)))
  
, dep1 = list(discrete = c(-8, -3, -2, -1), range = list(c(1, 4)))
, dep2 = list(discrete = c(-8, -3, -2, -1), range = list(c(1, 4)))
, dep3 = list(discrete = c(-8, -3, -2, -1), range = list(c(1, 4)))
, dep4 = list(discrete = c(-8, -3, -2, -1), range = list(c(1, 4)))
, dep5r = list(discrete = c(-8, -3, -2, -1), range = list(c(1, 4)))
, dep6 = list(discrete = c(-8, -3, -2, -1), range = list(c(1, 4)))
, dep7 = list(discrete = c(-8, -3, -2, -1), range = list(c(1, 4)))
, dep8r = list(discrete = c(-8, -3, -2, -1), range = list(c(1, 4)))
, dep9 = list(discrete = c(-8, -3, -2, -1), range = list(c(1, 4)))
, dep10 = list(discrete = c(-8, -3, -2, -1), range = list(c(1, 4)))
  
, anx1 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(1, 4)))
, anx2 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(1, 4)))
, anx3 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(1, 4)))
, anx4r = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(1, 4)))
, anx5 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(1, 4)))
, anx6 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(1, 4)))
, anx7 = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(1, 4)))
              
, hap = list(discrete = c(-8, -4, -3, -2, -1), range = list(c(1, 5)))
  
, lon1 = list(discrete = c(-8, -5, -4, -3, -2, -1), range = list(c(0, 3)))
, lon2 = list(discrete = c(-8, -5, -4, -3, -2, -1), range = list(c(0, 3)))
, lon3 = list(discrete = c(-8, -5, -4, -3, -2, -1), range = list(c(0, 3)))
              
, men = list(discrete = c(-3, -2, -1), range = list(c(1, 5)))
, act = list(discrete = c(-8, -3, -2, -1), range = list(c(0, 5)))
, alc = list(discrete = c(-8, -2, -1), range = list(c(0, 7)))
, smk = list(discrete = c(-8, -6, -5, -4, -2, -1), range = list(c(0, 60)))
               
, wei = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(70, 400)))
, hei = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(30, 90)))
, age = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(61, 91)))
               
, edu = list(discrete = c(-8, -6, -5, -4, -3, -2, -1), range = list(c(1, 4)))
, fri = list(discrete = c(-5, -4, -3, -2, -1), range = list(c(0, 5)))
, inc = list(discrete = c(-5, -4, -2, -1), range = list(c(1, 5))))

vars <- names(na_rules)

convert_to_na <- function(x, discrete_vals, ranges) {
  is_na <- x %in% discrete_vals
  for (r in ranges) is_na <- is_na | (x < r[1] | x > r[2])
  x[is_na] <- NA
  x}

df[vars] <- lapply(vars, \(v) convert_to_na(df[[v]], na_rules[[v]]$discrete, na_rules[[v]]$range))

df %>% describe() %>% paged_table()
```

# Missing
```{r}
colSums(is.na(df))

print(paste("Percentage of data that is missing:", 
            round(sum(is.na(df)) / prod(dim(df)) * 100, 2), "%"))
print(paste("Rows with complete data:", sum(complete.cases(df)), "/", 
            nrow(df), "(", round(sum(complete.cases(df)) / nrow(df) * 100, 2), "%)"))
```

# Imputation
Missing values imputed with the **missRanger** package (Mayer & Mayer, 2019).

**Author**: Mayer, M., & Mayer, M. M. (2019). *Package ‘missRanger’.* [R package], 820. CRAN.
```{r, message = FALSE, warning = FALSE, eval = FALSE}
set.seed(seed)
dfimputed <- missRanger(
  as.data.frame(df)
, pmm.k = 5 # predictive mean matching
, seed = seed
, verbose = 0) 
dfimputed %>% paged_table()
dfimputed %>% describe()

data <- dfimputed

save(data, file = "data.RData")
```

```{r}
load("data.RData")
```

# Casewise deletion
```{r, eval = FALSE}
# SKIPPED
data <- dfimputed

dffullrows <- df[complete.cases(df), ]
dffullrows %>% paged_table()

# data <- dffullrows
```

# Recoding
```{r}
reverse_scale <- function(x, min, max) {
  ifelse(is.na(x), NA, max + min - x)}

data <- data %>% 
  mutate(data
, dep5 = reverse_scale(dep5r, min = 1, max = 4)
, dep8 = reverse_scale(dep8r, min = 1, max = 4)
, anx4 = reverse_scale(anx4r, min = 1, max = 4)) %>%
  select(-dep5r, -dep8r, -anx4r)

sum_vars <- list(
  chr = paste0("chr", 1:10)
, adl = paste0("adl", 1:11)
, dep = paste0("dep", 1:10)
, anx = paste0("anx", 1:7)
, lon = paste0("lon", 1:3)
, com = paste0("com", 1:3))

sum_scale <- function(dat, cols, require_at_least = 0) {
  n_ok <- rowSums(!is.na(dat[, cols, drop = FALSE]))
  s    <- rowSums(dat[, cols, drop = FALSE], na.rm = TRUE)
  s[n_ok < require_at_least] <- NA
  s}

# full data
mins_required <- c(
  chr = 10
, adl = 11
, dep = 10
, anx = 7
, lon = 3
, com = 3)

for (v in names(sum_vars)) {
  data[[v]] <- sum_scale(data, sum_vars[[v]], require_at_least = mins_required[[v]])
  data <- data %>% select(-all_of(sum_vars[[v]]))}

# reversing scales
data <- data %>% 
  mutate(
  chr = reverse_scale(chr, min = 1, max = 10)
, adl = reverse_scale(adl, min = 1, max = 33))

# conversion
data <- data %>% mutate(bmi = wei*0.453592/((hei*2.54/100)^2)) %>% select(-wei, -hei)

# reorder columns
SA <- c(
  "chr"
, "adl"
, "phy"
, "cog"
, "soc"
)

data <- data %>% select(all_of(SA), everything())

data %>% paged_table()
data %>% describe %>% paged_table()

contvars <- c(
  "adl"
, "cog"
, "alc"
, "smk"
, "age"
, "dep"
, "anx"
, "lon"
, "com"
, "bmi")

ordvars <- c("chr"
, "act"
, "edu"
, "fri"
, "hap"
, "inc"
, "men"
, "phy"
, "soc")

catvars <- c()
```

# Distributions
```{r}
if (length(contvars) > 0) {
  df_cont <- data %>%
    select(all_of(contvars)) %>%
    pivot_longer(everything(), names_to = "variable", values_to = "value") %>%
    filter(!is.na(value))

  print(
    ggplot(df_cont, aes(x = value)) +
      geom_density(fill = "grey75", color = "grey25", linewidth = 0.3) +
      facet_wrap(~ variable, scales = "free") +
      theme_minimal() +
      labs(title = "Distributions of continuous predictors", x = NULL, y = "Density"))}

if (length(ordvars) > 0) {
  df_ord <- data %>%
    select(all_of(ordvars)) %>%
    pivot_longer(everything(), names_to = "variable", values_to = "value") %>%
    filter(!is.na(value)) %>%
    mutate(value = as.ordered(value))

  print(
    ggplot(df_ord, aes(x = value)) +
      geom_bar(fill = "grey75", color = "black", width = 1) +
      facet_wrap(~ variable, scales = "free_x") +
      theme_minimal() +
      labs(title = "Distributions of ordinal predictors", x = NULL, y = "Count"))}

if (length(catvars) > 0) {
  df_cat <- data %>%
    select(all_of(catvars)) %>%
    pivot_longer(everything(), names_to = "variable", values_to = "value") %>%
    filter(!is.na(value)) %>%
    mutate(value = fct_infreq(as.factor(value)))

  print(
    ggplot(df_cat, aes(x = value)) +
      geom_bar(fill = "grey75", color = "black", width = 0.7) +
      facet_wrap(~ variable, scales = "free_x") +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      labs(title = "Distributions of categorical predictors", x = NULL, y = "Count"))}
```

# Skewness
Skewness was detected with the **dlookr** package (Ryu, 2025).

**Author**: Ryu, C. (2025). *Package 'dlookr'* [R package]. CRAN. 
```{r}
data %>% find_skewness(index = FALSE, value = TRUE, thres = 0.5) %>% print()
```

# Correlations
Spearman correlations computed with rcorr() from the **hmisc** package (Harrell, 2019).

**Author**: Harrell Jr, F. E., & Harrell Jr, M. F. E. (2019). *Package ‘hmisc’* [R package]. CRAN.
```{r}
df_num <- data[, colnames(data)]
cor_res <- rcorr(as.matrix(df_num), type = "spearman")
cor_matrix <- cor_res$r
p_matrix <- cor_res$P

ggcorrplot(
  cor_matrix
, hc.order = TRUE,
, type = "upper"
, lab = TRUE,
, p.mat = p_matrix
, sig.level = 0.05
, insig = "blank"
, colors = c("violetred"
           , "white"
           , "steelblue"))
```

# Assumptions
Positive definitiveness was assessed with the **matrixcalc** package (Novomestky & Kelly, 2022).

**Author**: Novomestky, F., & Kelly, M. S. T. (2022). *Package ‘matrixcalc’.* [R Package]. CRAN.
```{r}
cormat <- cor(x = data, use = c("pairwise.complete.obs"))
is.positive.definite(cormat)
```

# Variable redundancy
Variable redundancy assessed with the **networktools** package (Jones & Jones, 2018).

**Author**: Jones, P., & Jones, M. P. (2018). *Package ‘networktools’.* [R Package]. CRAN.
```{r}
goldbricker(
  data, p = 0.05
, method = "hittner2003"
, threshold = 0.25
, corMin = 0.5
, progressbar = FALSE)
```

# Network estimation
Network was estimated with the **bootnet** package (Epskamp & Fried, 2025).

**Author**: Epskamp, S., & Fried, E. I. (2025). *Package ‘bootnet’* [R package]. CRAN.
```{r, message = FALSE, warning = FALSE, eval = FALSE}
set.seed(seed)

network <- estimateNetwork(
  data = data
, stepwise = TRUE
, default = "ggmModSelect" 
, corMethod = "spearman")

save(network, file = "network.RData")
```

```{r}
load("network.RData")
```

```{r}
boots <- 1000
nCores <- parallel::detectCores() - 2
```

```{r}
set.seed(seed)

test <- as.matrix(data)
cols <- ncol(test)
```

# Predictability
```{r, message = FALSE, warning = FALSE, eval = FALSE}
set.seed(seed)
fit_obj <- mgm(
  data = test
, type = rep('g', cols)
, level = rep('1',cols)
, lambdSel = 'EBIC',
ruleReg = 'OR')

predictability <- predict(
  object = fit_obj,
  data = test,
  errorCon = 'R2')

save(predictability, file = "predictability.RData")
```

```{r}
load("predictability.RData")
```

# Network simulation
Network simulation with **bootnet** package (Epskamp & Fried, 2025).

**Author**: Epskamp, S., & Fried, E. I. (2025). *Package ‘bootnet’* [R package]. CRAN.
```{r, message = FALSE, warning = FALSE, eval = FALSE}
sims <- netSimulator(
  network$graph
, nCases = c(1000, 2000, 3196)
, nReps = boots
, nCores = nCores
, default = "ggmModSelect"
, stepwise  = TRUE
, corMethod = "spearman")

save(sims, file = "sims.RData")
```


```{r}
load("sims.RData")
```

# Node Groups
```{r}
indexg1 <- c(1:5)
indexg2 <- c(6:19)

groups = list(
  "Successful Ageing" = indexg1
, "Influencing Factors" = indexg2)
```

# Network stability
```{r, eval = FALSE}
bootnp1 <- bootnet(
  network
, type = "nonparametric"
, nBoots = boots
, split  = TRUE
, nCores = nCores
, statistics = c("edge"))

save(bootnp1, file = "bootnp1.RData")

bootnp2 <- bootnet(
  network
, nBoots = boots
, type = "nonparametric"
, nCores = nCores
, statistics = c("bridgeExpectedInfluence")
, communities = groups)

save(bootnp2, file = "bootnp2.RData")

bootcd <- bootnet(
  network
, nBoots = boots
, type = "case"
, nCores = nCores
, statistics = c("bridgeExpectedInfluence",
                 "edge")
, communities = groups)

save(bootcd, file = "bootcd.RData")
```

```{r}
load("bootnp1.RData")
load("bootnp2.RData")
load("bootcd.RData")
```

# Edge stability
```{r}
# bridge stability graphs
bootcd %>% plot(
order = "sample"
, labels = TRUE
, statistics = c("edge")
, communities = groups)

# edge stability graphs

bootnp1 %>% plot("edge", plot = "difference", onlyNonZero = TRUE, order = "sample")
bootnp1 %>% plot(labels = FALSE, order = "sample")
sims %>% plot()
```

# Bridge centrality
```{r}
# bridge stability graphs
bootcd %>% plot(
order = "sample"
, labels = TRUE
, statistics = c("bridgeExpectedInfluence")
, communities = groups)
        
# stability coefficients
corStability(bootcd) # Bad (0-0.2), Acceptable (0.2-0.5), Good (0.5-0.7), Excellent (0.7-1).
        
bridge <- bridge(network$graph
, communities = c(rep('1', 5), rep('2', 14))
, useCommunities = "all"
, directed = NULL
, nodes = NULL)

# bridge values
bridge %>% print()
plot(bridge, include = "Bridge Expected Influence (1-step)", width = 4)

# bridge different test
bootnp2 %>% plot(statistics = "bridgeExpectedInfluence", plot = "difference")
```

# Community detection
```{r}
inetwork <- graph_from_adjacency_matrix(
  abs(as.matrix(network$graph))
, mode = "undirected"
, weighted = TRUE
, diag = FALSE)

algorithms <- list(
  spinglass = cluster_spinglass
, walktrap = cluster_walktrap
, louvain = cluster_louvain
, fast_greedy = cluster_fast_greedy)

results <- list()
for (algo_name in names(algorithms)) {
  com <- algorithms[[algo_name]](inetwork)
  results[[algo_name]] <- list(
    modularity = max(com$modularity),
    membership = com$membership)
  cat(algo_name, "modularity:", results[[algo_name]]$modularity, "\n")}

best <- names(which.max(sapply(results, function(x) x$modularity)))
community <- results[[best]]$membership
cat("Best algorithm:", best, "\n")

communitygroups <- as.list(community)
communitynumber <- length(unique(community))
```

# Network plot
```{r}
node_labels <- colnames(data)
node_names <- c(
  "Absence of chronic diseases"
, "Absence of difficulties in ADLs"
, "Physical health"
, "Cognitive performance"
, "Social participation"
, "Happiness"
, "Mental health"
, "Physical activity"
, "Alcohol consumption"
, "Smoking"
, "Age"
, "Educational attainment"
, "Number of friends"
, "Household income"
, "Depression"
, "Anxiety"
, "Loneliness"
, "Community participation"
, "Body-mass index")

communitygroups <- lapply(unique(community), function(comm_num) {which(community == comm_num)})
names(communitygroups) <- paste("Community", 1:length(communitygroups))

communityplot <- plot(
  
# network
  network
, layout = "spring"
, bidirectional = FALSE
, directed = FALSE
, minimum = 0.05
, GLratio = 3
  
# edges
, posCol = "steelblue"
, negCol = "violetred3"
, esize = 15
, edge.width = 1
, edge.labels = FALSE
, edge.label.cex = 1
  
# nodes
, shape = "circle"
, vsize = 6
, border.color = "#5b4c3a"
#, pie = nodeexplained
, pie = as.numeric(
        as.character(predictability$error[,2]))
, pieColor = rep("#D2CCC5", cols)

# labels
, label = node_labels
, label.font = 2
, label.scale.equal = TRUE
, nodeNames = node_names
  
# legend
, legend = TRUE
, legend.mode = "style1"
, legend.cex = 0.35
  
# community
, color = c(
  "papayawhip"
, "peachpuff4"
, "wheat3"
, "seashell3"
, "antiquewhite"
, "bisque3"
, "navajowhite")[1:max(community)][community]
, label.color = c(
  "#564D46"
, "gray100"
, "white"
, "#3F3D3A"
, "#564D46"
, "#564D46"
, "#564D46")[1:max(community)][community]
, groups = communitygroups)
```



# Print network
```{r, message = FALSE, warning = FALSE, eval = FALSE}
pdf(file = "plot.pdf", width = 8, height = 6)
plot(communityplot)
dev.off()
browseURL("plot.pdf") 
```

# Network metrics
```{r}
A <- network$graph
A <- as.matrix(A)

A_bin <- (A != 0) * 1

g <- graph_from_adjacency_matrix(A_bin, mode = "undirected", diag = FALSE)

avg_degree  <- mean(igraph::degree(g))
avg_spl     <- mean_distance(g, directed = FALSE, unconnected = TRUE)  # ignores unreachable pairs
gcc         <- igraph::transitivity(g, type = "global") # global clustering coefficient
density     <- edge_density(g, loops = FALSE)
diameter_g  <- diameter(g, directed = FALSE, unconnected = TRUE)

list(
  average_degree = avg_degree,
  average_shortest_path_length = avg_spl,
  global_clustering_coefficient = gcc,
  density = density,
  diameter = diameter_g
)
```


